#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <BLE2902.h>
#include "BLEHIDDevice.h"
#include "HIDTypes.h"
#include "HIDKeyboardTypes.h"

// 定义服务UUID
#define SERVICE_UUID        "1812"  // 人类接口设备服务
#define CHARACTERISTIC_UUID "2A4D"  // 键盘报告特性

// 引脚定义
#define BUTTON1_PIN 13
#define BUTTON2_PIN 12
#define BUTTON3_PIN 14
#define BUTTON4_PIN 27
#define BUTTON5_PIN 26
#define ENCODER_CLK 25
#define ENCODER_DT 33
#define ENCODER_SW 32

BLEHIDDevice* hid;
BLECharacteristic* input;

bool isConnected = false;
int encoderPos = 0;
int lastEncoderPos = 0;
int lastEncoded = 0;

// 按钮状态
bool buttonStates[5] = {false, false, false, false, false};
bool lastButtonStates[5] = {false, false, false, false, false};

// 连接状态回调
class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      isConnected = true;
      Serial.println("设备已连接");
    };

    void onDisconnect(BLEServer* pServer) {
      isConnected = false;
      Serial.println("设备已断开连接");
      pServer->startAdvertising();
    }
};

// 读取旋转编码器
int readEncoder() {
  int MSB = digitalRead(ENCODER_CLK);
  int LSB = digitalRead(ENCODER_DT);
  int encoded = (MSB << 1) | LSB;
  int sum = (lastEncoded << 2) | encoded;
  
  if(sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) encoderPos++;
  if(sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) encoderPos--;
  
  lastEncoded = encoded;
  return encoderPos;
}

void setup() {
  Serial.begin(115200);
  Serial.println("正在启动BLE键盘...");

  // 初始化按钮引脚
  pinMode(BUTTON1_PIN, INPUT_PULLUP);
  pinMode(BUTTON2_PIN, INPUT_PULLUP);
  pinMode(BUTTON3_PIN, INPUT_PULLUP);
  pinMode(BUTTON4_PIN, INPUT_PULLUP);
  pinMode(BUTTON5_PIN, INPUT_PULLUP);
  
  // 初始化编码器引脚
  pinMode(ENCODER_CLK, INPUT_PULLUP);
  pinMode(ENCODER_DT, INPUT_PULLUP);
  pinMode(ENCODER_SW, INPUT_PULLUP);

  // 初始化BLE设备
  BLEDevice::init("ESP32 5键编码器键盘");
  
  // 创建BLE服务器
  BLEServer *pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());
  
  // 创建HID设备
  hid = new BLEHIDDevice(pServer);
  hid->manufacturer()->setValue("ESP32");
  hid->pnp(0x02, 0xe502, 0xa111, 0x0210);
  hid->hidInfo(0x00, 0x02);
  
  // 设置报告映射
  const uint8_t reportMap[] = {
    USAGE_PAGE(1),      0x01,       // 通用桌面控制
    USAGE(1),           0x06,       // 键盘
    COLLECTION(1),      0x01,       // 应用
    REPORT_ID(1),       0x01,       //  报告ID (1)
    USAGE_PAGE(1),      0x07,       //  键盘/小键盘
    USAGE_MINIMUM(1),   0xE0,       //  左Control键
    USAGE_MAXIMUM(1),   0xE7,       //  右GUI键
    LOGICAL_MINIMUM(1), 0x00,       //  每个位代表一个按键
    LOGICAL_MAXIMUM(1), 0x01,       
    REPORT_COUNT(1),    0x08,       //  8个修饰键位
    REPORT_SIZE(1),     0x01,       
    INPUT(1),           0x02,       //  数据,变量,绝对值
    REPORT_COUNT(1),    0x01,       //  1字节填充
    REPORT_SIZE(1),     0x08,       
    INPUT(1),           0x01,       //  常量
    REPORT_COUNT(1),    0x06,       //  6个按键
    REPORT_SIZE(1),     0x08,       
    LOGICAL_MINIMUM(1), 0x00,       
    LOGICAL_MAXIMUM(1), 0x65,       //  101键
    USAGE_MINIMUM(1),   0x00,       
    USAGE_MAXIMUM(1),   0x65,       
    INPUT(1),           0x00,       //  数据,数组
    END_COLLECTION(0)               // 结束
  };
  
  hid->reportMap((uint8_t*)reportMap, sizeof(reportMap));
  input = hid->inputReport(1); // 报告ID=1
  hid->setBatteryLevel(100);
  
  // 启动服务
  pServer->getAdvertising()->setAppearance(HID_KEYBOARD);
  pServer->getAdvertising()->addServiceUUID(hid->hidService()->getUUID());
  pServer->getAdvertising()->start();
  
  Serial.println("BLE键盘已准备好连接");
}

// 发送按键
void sendKey(uint8_t key) {
  uint8_t msg[] = {0x00, 0x00, key, 0x00, 0x00, 0x00, 0x00, 0x00};
  input->setValue(msg, sizeof(msg));
  input->notify();
  
  // 释放按键
  uint8_t release[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  input->setValue(release, sizeof(release));
  input->notify();
}

void loop() {
  if (!isConnected) {
    delay(100);
    return;
  }

  // 读取按钮状态
  buttonStates[0] = !digitalRead(BUTTON1_PIN);
  buttonStates[1] = !digitalRead(BUTTON2_PIN);
  buttonStates[2] = !digitalRead(BUTTON3_PIN);
  buttonStates[3] = !digitalRead(BUTTON4_PIN);
  buttonStates[4] = !digitalRead(BUTTON5_PIN);
  
  // 检查按钮状态变化
  for (int i = 0; i < 5; i++) {
    if (buttonStates[i] != lastButtonStates[i]) {
      if (buttonStates[i]) {
        // 按钮按下，发送对应按键
        switch(i) {
          case 0: sendKey(0x1E); break; // 按钮1 -> 'a'
          case 1: sendKey(0x1F); break; // 按钮2 -> 's'
          case 2: sendKey(0x20); break; // 按钮3 -> 'd'
          case 3: sendKey(0x21); break; // 按钮4 -> 'f'
          case 4: sendKey(0x22); break; // 按钮5 -> 'g'
        }
      }
      lastButtonStates[i] = buttonStates[i];
    }
  }
  
  // 处理编码器旋转
  int encoderPos = readEncoder();
  if (encoderPos != lastEncoderPos) {
    if (encoderPos > lastEncoderPos) {
      sendKey(0x52); // 向上箭头
    } else {
      sendKey(0x51); // 向下箭头
    }
    lastEncoderPos = encoderPos;
    delay(50); // 防抖
  }
  
  // 处理编码器按钮
  static bool lastEncoderButtonState = true;
  bool encoderButtonState = digitalRead(ENCODER_SW);
  if (encoderButtonState != lastEncoderButtonState) {
    if (!encoderButtonState) {
      sendKey(0x28); // 回车键
    }
    lastEncoderButtonState = encoderButtonState;
  }
  
  delay(10);
}